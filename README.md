# -FILE-HANDLING-UTILITY

*COMPANY*: CODTECH IT SOLUTIONS

*NAME*: YASH SAVANI

*INTERN ID*: CT12WOND

*DOMAIN*: JAVA PROGRAMMING

*DURATION*: 12 WEEKS

*MENTOR*: NEELA SANTHOSH

## DESCRIPTON : 

  Task 1: File Handling in Java

**Purpose of Task:**

Task 1 of my internship focused on mastering the concept of **file handling using Java**. The main goal of this task was to build a solid foundation for handling files — an essential aspect of backend development and real-world applications that rely on persistent data storage. This task helped me understand how Java interacts with the file system to create, read, write, append, delete, and search files efficiently.

By building a simple console-based file management system, I was able to explore Java’s powerful I/O classes and gain practical experience in writing code that manipulates files and directories directly. The task was designed to give me a hands-on understanding of how data can be managed through file systems without using a database — a skill particularly useful for lightweight tools, logs, configuration managers, and local data processors.

---

**Tools and Technologies Used:**

- **Java SE (Standard Edition)** – Core Java was used to implement all file operations.
- **JDK 17** – The Java Development Kit version used for compilation and execution.
- **Spring Tool Suite (STS)** – A powerful IDE tailored for Java and Spring development. STS was used to write, debug, and run the Java application.
- **java.io & java.util Packages** – Core Java libraries such as `File`, `FileWriter`, `BufferedReader`, `Scanner`, `FileReader`, etc., were used to perform file I/O operations.
- **Command Line Interface (CLI)** – The project was executed via console to simulate real-world terminal utilities and command-line tools.

---

**Features Implemented:**

The application provides a menu-driven interface for users to interact with the file system through the following features:

1. **Create New File** – Prompts the user to enter a file name and creates a file in the project directory if it doesn’t already exist.
2. **Write to File** – Allows the user to write custom content into the file. If the file doesn’t exist, it is created automatically.
3. **Append to File** – Enables appending additional content to an existing file without erasing previous data.
4. **Read File** – Reads and displays the content of a selected file using buffered reading techniques for efficient data handling.
5. **Delete File** – Deletes an existing file after confirming the operation, with appropriate exception handling for edge cases.
6. **Search in File** – Provides functionality to search for a word or phrase within a file and return the lines where matches were found.

---

**Applicability of the Task:**

The concepts covered in this task are widely applicable in many real-world software development scenarios:

- **Log File Management** – Recording and reading logs is crucial in debugging and monitoring software systems.
- **Text Editors and File Processors** – The basic functionality of text editors relies on reading and writing to files.
- **Data Storage for Lightweight Applications** – CLI or desktop apps often use flat files for storage in the absence of a database.
- **Configuration Handling** – Many applications read configuration files at runtime to adjust settings.
- **Foundation for Advanced Topics** – This task lays the groundwork for understanding serialization, object I/O, and even file-based caching mechanisms.

---

**Conclusion:**

This task significantly boosted my confidence in using Java for file-related operations. Working in **Spring Tool Suite (STS)** provided a smooth and developer-friendly environment for building and testing Java applications. By implementing this console-based file manager, I not only improved my grasp on Java I/O but also learned how to handle exceptions gracefully, validate user inputs, and interact with the file system programmatically. The experience gained here will undoubtedly be useful in more complex projects involving data persistence, file analysis, and backend processing.
